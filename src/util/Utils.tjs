// Copyright (C) 2015 Biscrat
FILE_INCLUDE_GUARD

// shortcuts

global.dm = Debug.message;
global.getKeys = Scripts.getObjectKeys;

/**
 * Output an object's members.
 * @param object object value The value to output.
 * @param func function out Called to output message.
 */
Func(dv)(value:any, out:Function = global.Debug.message) {
    checkArgs
    var printer = %[
        "count" => 0,
        "indent" => LMD() {
            flash();
            ++this.count; return this;
        },
        "outdent" => LMD() {
            flash();
            --this.count;
            return this;
        },
        "buffer" => "",
        "push" => LMD(line) {
            buffer += line;
            return this;
        },
        "flash" => LMD(line) {
            buffer += line;
            if (buffer.length === 0) return this;
            out("\t".repeat(this.count) + buffer);
            buffer = "";
            return this;
        }
    ];
    printer.out = out;
    var stack = [ value ];
    var pushDictionary = LMD(currentValue, endString) {
        var key = global.getKeys(currentValue);
        stack.push(%[
            "dvValueType" => "Dictionary",
            "value" => currentValue,
            "key" => key,
            "index" => 0,
            "count" => key.count,
            "endString" => endString
        ]);
    } incontextof %[ stack:stack ];
    for(;;) {
        if (stack.count === 0) break;
        var currentValue = stack.pop();

        switch(typeof currentValue) {
        case "Object":
            if (currentValue === null) {
                printer.push("(null)");
                break;
            }
            try { currentValue instanceof "Array"; }
            catch {
                printer.push("(native?)" + currentValue);
                break;
            }
            if (currentValue instanceof "Array") {
                stack.push(%[
                    "dvValueType" => "Array",
                    "value" => currentValue,
                    "index" => 0,
                    "count" => currentValue.count
                ]);
                printer.flash("[").indent();
            } else if (currentValue instanceof "Dictionary") {
                switch (currentValue.dvValueType) {
                case "Array":
                    if (currentValue.index === currentValue.count) {
                        printer.outdent().push("]");
                    } else {
                        if (currentValue.index !== 0) {
                            printer.flash(",");
                        }
                        ++currentValue.index;
                        stack.push(currentValue, &currentValue.value[currentValue.index-1]);
                    }
                    break;
                case "Dictionary":
                    if (currentValue.index === currentValue.count) {
                        printer.outdent().push(currentValue.endString);
                    } else {
                        if (currentValue.index !== 0) {
                            printer.flash(",");
                        }
                        with (currentValue) {
                            printer.push("\""+ .key[.index] + "\" => ");
                            ++.index;
                            stack.push(currentValue, &.value[.key[.index-1]]);
                        }
                    }
                    break;
                case void:
                    printer.flash("%[").indent();
                    pushDictionary(currentValue, "]");
                    break;
                }
            } else if (currentValue instanceof "Class") {
                printer.flash("(class)" + currentValue + " {").indent();
                pushDictionary(currentValue, "}");
            } else if (currentValue instanceof "Function") {
                printer.push("(function)" + currentValue);
            } else if (currentValue instanceof "Property") {
                printer.push("(property)" + currentValue);
            } else {
                printer.flash("(object)" + currentValue + " {").indent();
                pushDictionary(currentValue, "}");
            }
            break;
        case "void": printer.push("(void)"); break;
        case "Integer": printer.push("(int)" + currentValue); break;
        case "Real": printer.push("(real)" + currentValue); break;
        case "String": printer.push("(string)\"" + currentValue + "\""); break;
        case "Octet":
            printer.push("(octet)<% ");
            for (var i = 0; i < currentValue.length; ++i) {
                printer.push("%02x ".sprintf(currentValue[i]));
            }
            printer.push("%>");
            break;
        }
    }
    printer.flash();
}


/**
 * Replace old strings between braces to new strings.
 * @param string message The string contains strings between braces to be replaced.
 * @param strign lists* The old strings and new strings in turn.
 * @return string The message expanded.
 */
Func(expandMessage)(message:string, lists*) {
    checkArgs
    assert(lists.count % 2 === 0)
    for (var i = lists.count-2; i >= 0; i -= 2) {
        message = message.replace(@"/\\{&lists[i];\\}/g"!, lists[i+1]);
    }
    return message;
}

/**
 * Create string with Regexp.
 * @param object reg The RegExp object.
 * @param string targetString The string to match a regular expression.
 * @param string patternString The string where the placeholders like $1 will be replaced by matched string.
*/
global.createStringWithRegExp = LMD(reg:RegExp, targetString:string, patternString:string) {
    checkArgs
    var start = reg.start;
    reg.exec(targetString);
    while(1) {
        var newString = patternString.replace(r, (f incontextof %[reg:reg]));
        if (newString === patternString) { break; }
        patternString = newString;
    }
    reg.start = start;
    return patternString;
} incontextof %[
    r:/\$[0-9]+/,
    f:LMD(matches) {
        var num = +matches[0].substr(1);
        return reg.matches[num];
    }
];
