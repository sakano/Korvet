// Copyright (C) 2015 Biscrat
FILE_INCLUDE_GUARD

ClassExtends(NovelMode, GameMode)
{
    property inTransition { getter { return this._systemCommandHandler._inTransition; } }
    property inAction { getter { return this._actionCount > 0; } }

    Func(onTick)() {
        this._runner.onTick(...);
        if (this.inTransition) {
            for (var i = 0; i < this._drawables.count; ++i) {
                this._drawables[i].drawInTransition();
            }
        } else {
            for (var i = 0; i < this._drawables.count; ++i) {
                this._drawables[i].draw();
            }
        }
    }

    Func(loadScript)(path:string+, label:string+) {
        checkArgs
        if (path !== void) {
            var error = this._parser.initStorage(path);
            if (!success(error)) {
                return error;
            }
        }

        if (label !== void) {
            var error = this._parser.goToLabel(label);
            if (!success(error)) {
                return error;
            }
        }
        return SUCCESS;
    }

    Func(resumeCommandLoopAsync)() {
        global.gAsyncCaller.callOnce(this._resumeCommandLoop);
    }

    Func(onDrawMessageCompleted)() {
        // メッセージを最後まで描画し終わったときに呼ばれる
        // クリックされたら遅延実行、アクション、トランジションの実行をスキップしてコマンド実行を再開
        global.gAsyncCaller.call(this._runner.run, global.SequenceRunner.sequence()
            .wait("click")
            .call(this._trigger, "skipDelay")
            .call(this._trigger, "skipAction")
            .call(this._trigger, "skipTrans")
            .call(this.resumeCommandLoopAsync));
    }

    Func(repageWhileDrawingMessage)() {
        // メッセージの描画の途中で次のページに進む必要があるときに呼ばれる
        // クリックされたらメッセージ描画を再開
        global.gAsyncCaller.call(this._runner.run, global.SequenceRunner.sequence()
            .wait("click")
            .factory(this._messageCommandHandler.createResumeDrawingMessageSequence));
    }

    Func(onTransitionBegin)() {
        this._trigger("skipTrans");
        for (var i = 0; i < this._drawables.count; ++i) {
            this._drawables[i].beforeTransition();
        }
    }

    Func(onTransitionCompleted)() {
        this._foreLayer <-> this._backLayer;
        for (var i = 0; i < this._drawables.count; ++i) {
            this._drawables[i].afterTransition();
        }
    }

    Func(onActionBegin)() {
        ++this._actionCount;
    }

    Func(onActionEnd)() {
        --this._actionCount;
        assert(this._actionCount >= 0)
        if (this._actionCount <= 0) {
            this._actionCount = 0;
            this._trigger("allActionCompleted");
        }
    }



    var _parser;
    var _runner;

    var _commandHandlers = [];
    var _drawables = [];
    var _messageCommandHandler;

    var _screenLayer;
    var _foreLayer;
    var _backLayer;
    var _actionCount = 0;

    Constructor(game, currentTick) {
        super.GameMode(game);

        this.bindMapWindowEvent(%[
            ObservableWindowEventType_LeftClick   => this._onLeftClick,
            ObservableWindowEventType_RightClick  => this._onRightClick,
            ObservableWindowEventType_MiddleClick => this._onMiddleClick,
            ObservableWindowEventType_MouseWheel  => this._onMouseWheel
        ]);

        this._runner = new global.SequenceRunner(currentTick);

        this._screenLayer = getScreen();
        this._screenLayer.visible = true;

        this._foreLayer = this._createParentLayer(this._screenLayer);
        this._backLayer = this._createParentLayer(this._screenLayer);
        this._foreLayer.visible = true;

        this._initParser();
        this._initCommandHandlers();

        global.gScriptLogger.setParser(this._parser);
    }

    Finalize() {
        super.finalize();
        invalidate this._runner;
        invalidate this._parser;
        this._commandHandlers.dispose();
        invalidate this._commandHandlers;
        this._drawables.dispose();
        invalidate this._drawables;
        invalidate this._screenLayer;
        invalidate this._foreLayer;
        invalidate this._backLayer;
        invalidate this._worldMatrix;
    }

    Func(_initParser)() {
        this._parser = new global.KorvetParser();
        this._parser.setModule(new global.MacroParserModule(), PriorityQueue_Highest);
        this._parser.setModule(new global.PageBeginEndParserModule(), PriorityQueue_Normal);
    }

    Func(_initCommandHandlers)() {
        this._systemCommandHandler = new global.SystemCommandHandler(this);
        this._commandHandlers.add(this._systemCommandHandler);

        var stageCommandHandler = new global.StageCommandHandler(this, this._foreLayer, this._backLayer);
        this._commandHandlers.add(stageCommandHandler);
        this._drawables.add(stageCommandHandler);

        var tachieCommandHandler = new global.TachieCommandHandler(this, this._foreLayer, this._backLayer, "楓");
        tachieCommandHandler.alignment = SpriteAlignment_BottomCenter;
        this._commandHandlers.add(tachieCommandHandler);
        this._drawables.add(tachieCommandHandler);

        var messageCommandHandler = new global.MessageCommandHandler(this, this._foreLayer, this._backLayer);
        this._commandHandlers.add(messageCommandHandler);
        this._drawables.add(messageCommandHandler);
        this._messageCommandHandler = messageCommandHandler;
    }

    Func(_createTargetLayer)(parentLayer:Layer) {
        var targetLayer = new global.Layer(parentLayer.window, parentLayer);
        targetLayer.setSize(parentLayer.width, parentLayer.height);
        targetLayer.visible = true;
        return targetLayer;
    }

    Func(_createParentLayer)(parentLayer:Layer) {
        var layer = new global.Layer(parentLayer.window, parentLayer);
        layer.setSize(parentLayer.width, parentLayer.height);
        layer.focusable = false;
        layer.ignoreHintSensing = true;
        layer.useAttention = false;
        //layer.type = ltBinder;
        layer.face = dfAuto;
        layer.setSize(parentLayer.width, parentLayer.height);
        layer.fill(0);
        //layer.hasImage = false;
        layer.visible = false;
        return layer;
    }

    Func(_trigger)(label:string) {
        checkArgs
        this._runner.trigger(...);
    }

    Func(_waitTrigger)(label:string, callback:Function, args*) {
        checkArgs
        this._runner.run(global.SequenceRunner.sequence().wait(label).call(callback, args*));
    }

    Func(_resumeCommandLoop)() {
        while (true) {
            // 次のコマンドを得る
            var command = %[];
            var error = _parser.getNextCommand(command);

            // パース中にエラーが発生したら停止
            if (!success(error)) {
                global.gScriptLogger.onScriptError(ASSERT_SCRIPT_PARSER_ERROR, "MES", error.message);
                break;
            }

            // コマンドが得られなかったら停止
            if (command.isEmpty()) break;

            // コマンドを実行する
            var interrupt = this._doCommand(command);
            if (interrupt) return;
        }
    }

    Func(_doCommand)(command:Dictionary) {
        checkArgs
        // delay属性が存在するなら遅延実行
        if (command.attributeValues.delay !== void) {
            var delayTime = global.gScriptLogger.validateAttribute("1", "delay", command.attributeValues, AttributeType_Verified, AttributeValueType_Integer, 1);
            // delay属性を消去
            command.attributeNames.remove("delay");
            delete command.attributeValues.delay;
            // コマンドを実行
            this._runner.run(global.SequenceRunner.sequence()
                .wait("update")
                .beginSkip("skipDelay")
                    .wait(delayTime)
                    .call(this._doCommandImmediately, command)
                    .call(this._doUpdateCommand)
                .endSkip()
            );
            return false;
        }
        return this._doCommandImmediately(...);
    }

    Func(_doCommandImmediately)(command:Dictionary) {
        checkArgs
        // コマンドを_commandHandlersに通知して実行
        var interrupt = false;
        for (var i = 0; i < this._commandHandlers.count; ++i) {
            var result = this._commandHandlers[i].onCommand(command);
            if (result === void) continue;
            if (result.trans !== void) {
                this._systemCommandHandler.registerTransInfo(result.trans);
            }
            if (result.sequences !== void) for (var i = 0; i < result.sequences.count; ++i) {
                this._runner.run(result.sequences[i]);
            }
            if (result.interrupt) interrupt = true;
        }
        return interrupt;
    }

    Func(_doUpdateCommand)() {
        this._doCommandImmediately(%[
            name : "update",
            attributeNames : [],
            attributeValues : %[]
        ]);
    }

    Func(_onLeftClick)(x:int, y:int, shift:int) {
        this._trigger("click");
    }

    Func(_onRightClick)(x:int, y:int ,shift:int) {
        this._trigger("click");
    }

    Func(_onMiddleClick)(x:int, y:int, shift:int) {
        this._trigger("click");
    }

    Func(_onMouseWheel)(shift:int, delta:int, x:int, y:int) {
        this._trigger("click");
    }
}
